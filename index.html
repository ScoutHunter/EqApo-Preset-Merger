<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EqAPO Presets Merger</title>

<style>
:root{
  --bg:#071022;
  --card:#0b1220;
  --muted:#9aa4b2;
  --accent:#7c9cff;
  --value:#f0f0f0;
  --panel-padding:16px;
  --radius:12px;
}

html,body{
  margin:0;
  padding:0;
  min-height:100%;
  font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;
  background:var(--bg);
  color:#e6eef8;
}

<!-- .wrap{max-width:95vw;margin:20px auto;padding:18px;} -->
<!-- header{display:flex;align-items:flex-start;gap:16px;flex-wrap:wrap;} -->
<!-- h1{margin:10px 0;font-weight:600;font-size:20px;} -->

.panel{
  background:var(--card);
  border-radius:var(--radius);
  padding:var(--panel-padding);
  box-shadow:0 8px 40px rgba(0,0,0,0.6);
}

button.primary{
  background:linear-gradient(90deg,var(--accent),#5b8cff);
  border:0;
  padding:8px 12px;
  border-radius:8px;
  color:white;
  font-weight:600;
  cursor:pointer;
}

<!-- input[type=file]{display:none} -->
<!-- .row{display:flex;gap:10px;margin-top:12px;} -->
<!-- .muted{color:var(--muted);font-size:13px;} -->

/* ---------------- SETTINGS BAR ---------------- */
.settings-bar{
  display:flex;
  gap:25px;
  <!-- margin:0px 0 0px 0; -->
  width:100%;
  flex-wrap:wrap;
  box-sizing:border-box;
}

/* ================= COMMON CARD STYLES ================= */
.setting-card {
  background: rgba(255,255,255,0.03);
  padding: 8px;
  border-radius: 10px;
  width: 150px;       
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  box-sizing: border-box;
}

.setting-title {
  font-size: 13px;
  text-align: center;
  font-weight: 500;
  margin-bottom: 6px;
}

.setting-contents {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100%;
  gap: 10px; /* uniform spacing between content blocks */
}

.smart-top {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 8px; /* spacing between toggle and slider */
}

.slider-group {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 4px; /* spacing between label, slider, and note */
  width: 100%;
}

.slider-label {
  font-size: 12px;
  color: var(--muted);
  text-align: center;
}

.note {
  font-size: 11px;
  color: var(--muted);
  text-align: center;
}

/* ================= SLIDER STYLING ================= */
.setting-card input[type=range] {
  -webkit-appearance: none;
  width: 95%;          /* fixed width for horizontal alignment */
  height: 6px;         
  background: rgba(255,255,255,0.2);
  border-radius: 3px;
}

.setting-card input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background-color: var(--accent);
  border-radius: 50%;
  cursor: pointer;
}

.setting-card input[type=range]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background-color: var(--accent);
  border-radius: 50%;
  cursor: pointer;
}

/* ================= TOGGLE STYLING ================= */
.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider-round {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: rgba(255,255,255,0.1);
  border-radius: 20px;
  transition: 0.3s;
}

.slider-round:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: var(--accent);
  border-radius: 50%;
  transition: 0.3s;
}

.switch input:checked + .slider-round {
  background-color: rgba(124,156,255,0.4);
}

.switch input:checked + .slider-round:before {
  transform: translateX(20px);
}


/* ---------------- MAIN PANEL ---------------- */
.main-panel{
  display:flex;
  gap:20px;
  margin-top:12px;
}

.presets-left {
  display: flex;
  flex-direction: column;
  flex: 0 0 350px; /* keeps your width */
}

.files-list {
  flex: 1;           /* fills all available height of .presets-left */
  overflow: auto;
  padding: 10px;
  border-radius: 10px;
  background: rgba(255,255,255,0.02);
}


.file-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:5px 5px;
  border-radius:8px;
  background:rgba(255,255,255,0.03);
  margin-bottom:5px;
}

.file-left{
  display:flex;
  align-items:center;
  gap:10px;
  max-width:100%;
}

<!-- .file-left input[type=checkbox]{ -->
  <!-- margin:0; -->
  <!-- transform:scale(1.1); -->
<!-- } -->

.file-left .name{
  font-size:13px;
  color:var(--value);
  word-break:break-word;
  max-width:260px;
}

.small-btn{
  background:transparent;
  border:1px solid rgba(255,255,255,0.04);
  padding:4px 7px;
  border-radius:6px;
  color:var(--muted);
  font-size:12px;
  cursor:pointer;
}

.curve-right{
  flex:1 1 auto;
  display:flex;
  flex-direction:column;
  gap:8px;
  min-width:360px;
}

#plotCanvas{
  width:100%;
  height:640px;
  <!-- border-radius:0px; -->
  background:#071322;
  display:block;
}

.code-out{
  background:#071322;
  padding:10px;
  border-radius:10px;
  font-family:monospace;
  font-size:13px;
  white-space:pre-wrap;
}

@media(max-width:1100px){
  .main-panel{flex-direction:column}
  .presets-left{flex: 0 0 0px}
  #plotCanvas{height:300px}
}

</style>
</head>

<body>
<div class="wrap">

<header>
  <h1>EQAPO Merger</h1>
  <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
    <button id="exportBtnHeader" class="primary">Download merged preset</button>
  </div>
</header>

<div class="panel">
  <div class="row">
    <input id="fileInput" type="file" accept=".txt,.cfg,.ini" multiple />
    <button id="chooseBtn" class="primary">Add presets</button>
  </div>

  <div class="main-panel">

    <div class="presets-left">
      <div class="files-list" id="filesList">
        <div class="muted">No presets loaded.</div>
      </div>
    </div>

    <div class="curve-right">
      <!-- SETTINGS BAR -->
      <div class="settings-bar">

		<!-- ================= EXAMPLE: Y-RANGE CARD ================= -->
		<div class="setting-card">
		  <div class="setting-title">Curve range</div>

		  <div class="setting-contents">
			<div class="slider-group">
			  <div class="slider-label">Max dB</div>
			  <input id="maxDb" type="range" min="0" max="12" value="0">
			  <span class="note"><span id="maxDbLabel">0</span> dB</span>
			</div>

			<div class="slider-group">
			  <div class="slider-label">Min dB</div>
			  <input id="minDb" type="range" min="-24" max="-1" value="-12">
			  <span class="note"><span id="minDbLabel">-12</span> dB</span>
			</div>
		  </div>
		</div>
		
		<!-- ================= EXAMPLE: SMART MERGE CARD ================= -->
		<div class="setting-card">
		  <div class="setting-title">Smart Merge</div>

		  <div class="setting-contents">
			<div class="smart-top">
			  <label class="switch">
				<input type="checkbox" id="smartMergeToggle">
				<span class="slider-round"></span>
			  </label>
			</div>

			<div class="slider-group">
			  <div class="slider-label">Radius</div>
			  <input type="range" id="mergeSlider" min="0" max="1000" value="0">
			  <span class="note"><span id="mergeLabel">Exact frequency</span></span>
			</div>
		  </div>
		</div>
		
      </div>
      <canvas id="plotCanvas"></canvas>
      <div id="mergedText" class="code-out"></div>
    </div>
  </div>
</div>


<script>
/* ========= UI elements ========= */
const fileInput = document.getElementById('fileInput');
const chooseBtn = document.getElementById('chooseBtn');
const exportBtnHeader = document.getElementById('exportBtnHeader');
const filesList = document.getElementById('filesList');
const mergedText = document.getElementById('mergedText');
const canvas = document.getElementById('plotCanvas');
const ctx = canvas.getContext('2d');
const minDb = document.getElementById('minDb');
const maxDb = document.getElementById('maxDb');
const minDbLabel = document.getElementById('minDbLabel');
const maxDbLabel = document.getElementById('maxDbLabel');
const smartMergeToggle = document.getElementById('smartMergeToggle');
const mergeSlider = document.getElementById('mergeSlider');
const mergeLabel = document.getElementById('mergeLabel');

let presets = [];
let lastMerged = null;

/* === Regexes === */
const PREAMP_RE = /Preamp:\s*([\-\d\.]+)/i;
const FILTER_RE = /Filter\s*\d+:\s*ON\s*(\w+)\s*Fc\s*([\d\.]+)\s*Hz\s*Gain\s*([\-\d\.]+)\s*dB\s*Q\s*([\d\.]+)/i;

/* === color palette === */
const COLOR_PALETTE = [
  '#ff6b6b','#4ecdc4','#ffe66d','#5dade2','#bb8fce',
  '#48c9b0','#f4d03f','#ec7063','#7c9cff','#2ecc71'
];

function colorForIndex(i){
  return COLOR_PALETTE[i % COLOR_PALETTE.length];
}

/* === Event wiring === */
chooseBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', handleFiles);
exportBtnHeader.addEventListener('click', handleExport);

minDb.addEventListener('input', () => {
  minDbLabel.textContent = minDb.value;
  updatePlot();
});

maxDb.addEventListener('input', () => {
  maxDbLabel.textContent = maxDb.value;
  updatePlot();
});

smartMergeToggle.addEventListener('change', updatePlot);

mergeSlider.addEventListener('input', () => {
  const radius = computeMergeRadius(mergeSlider.value);
  if (radius === 0) {
    mergeLabel.textContent = 'Exact frequency';
  } else {
    mergeLabel.textContent = Math.round(radius) + " Hz";
  }
  updatePlot();
});

/* ========== File handling & parsing ========== */
async function handleFiles() {
  if (!fileInput.files.length) return;

  for (const file of fileInput.files) {
    if (presets.some(p => p.name === file.name)) continue;

    const text = await file.text();
    const parsed = parsePreset(text);

    presets.push({
      name: file.name,
      preamp: parsed.preamp,
      filters: parsed.filters,
      enabled: true,
      color: colorForIndex(presets.length)
    });
  }

  renderFileList();
  updatePlot();
  fileInput.value = null;
}

function parsePreset(text){
  const lines = text.split(/\r?\n/);
  let preamp = 0;
  const filters = [];

  for (const raw of lines){
    const line = raw.trim();
    if (!line) continue;

    const pm = line.match(PREAMP_RE);
    if (pm){
      preamp = parseFloat(pm[1]);
      continue;
    }

    const fm = line.match(FILTER_RE);
    if (fm){
      filters.push({
        type: fm[1].toUpperCase(),
        fc: parseFloat(fm[2]),
        gain: parseFloat(fm[3]),
        q: parseFloat(fm[4])
      });
    }
  }
  return { preamp, filters };
}

function computeMergeRadius(v){
  v = v | 0;
  // special case: slider at zero = exact frequency
  if (v === 0) return 0;
  const logMin = Math.log10(1);        // 0
  const logMax = Math.log10(1000);     // 3
  const t = v / 1000;                  // 0 → 1
  const logVal = logMin + t * (logMax - logMin);
  return Math.pow(10, logVal);
}
function parseMergeSliderValue(){
  if (!smartMergeToggle.checked) return 0;     // disables merging, not display
  return computeMergeRadius(mergeSlider.value);
}

// --- main simpleMerge function ---
function simpleMerge(presetEntries){
  if(!presetEntries || presetEntries.length===0) return { preamp:0, filters:[] };
  const n = presetEntries.length;
  const mergedPreamp = presetEntries.reduce((s,p)=>s+p.preamp,0)/n;

  const allFilters = presetEntries.flatMap(p => p.filters.map(f => ({ ...f })));
  const mergedFilters = [];
  const used = new Array(allFilters.length).fill(false);

  const smart = smartMergeToggle.checked;
  const radius = smart ? parseInt(mergeSlider.value) : 0;

  for(let i=0;i<allFilters.length;i++){
    if(used[i]) continue;
    const f1 = allFilters[i];

    let group = [f1];
    used[i] = true;

    if(smart){
      let added;
      do {
        added = false;
        for(let j=0;j<allFilters.length;j++){
          if(used[j]) continue;
          const f2 = allFilters[j];
          // merge filters if same type AND within radius
          if(f1.type===f2.type && Math.abs(f1.fc - f2.fc) <= radius){
            group.push(f2);
            used[j] = true;
            added = true;
          }
        }
      } while(added);
    }

    // compute merged filter
    const avgFc = group.reduce((s,f)=>s+f.fc,0)/group.length;
    const totalGain = group.reduce((s,f)=>s+f.gain,0);
    const avgQ = group.reduce((s,f)=>s+f.q,0)/group.length;

    mergedFilters.push({ type:f1.type, fc:avgFc, gain:totalGain/n, q:avgQ });
  }

  mergedFilters.sort((a,b)=>a.fc-b.fc);
  return { preamp: mergedPreamp, filters: mergedFilters };
}

/* ======= Helpers for plotting ======= */
function mergedGainAtFreqDb(freq, merged){
  return presetGainAtFreqDb(freq, merged);
}

function presetGainAtFreqDb(freq, preset){
  let totalLinear = 1.0;
  for(const f of preset.filters){
    const coeffs = biquadCoeffs(f.type, f.fc, f.q, f.gain);
    if(coeffs){
      totalLinear *= biquadMagnitudeAt(freq, coeffs);
    } else {
      totalLinear *= dbToLinear(gaussianApproxMagnitudeDb(freq, f));
    }
  }
  return linearToDb(totalLinear) + (preset.preamp||0);
}

/* ========== Export builder (keeps format, but cleaned) ========== */
function buildMergedTextHelper(merged){
  let out = `Preamp: ${merged.preamp.toFixed(2)} dB`;
  merged.filters.forEach((f,i)=>{
    out += `\nFilter ${i+1}: ON ${f.type} Fc ${f.fc.toFixed(2)} Hz Gain ${f.gain.toFixed(2)} dB Q ${f.q.toFixed(2)}`;
  });
  return out;
}

function handleExport(){
  const enabledPresets = presets.filter(p=>p.enabled);
  const merged = simpleMerge(enabledPresets);
  const txt = buildMergedTextHelper(merged);
  const blob = new Blob([txt], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'ApoMerged.txt'; a.click(); URL.revokeObjectURL(url);
}

/* ========== File list rendering (name colored to curve) ========== */
function renderFileList() {
  filesList.innerHTML = '';

  if (!presets.length) {
    filesList.innerHTML = '<div class="muted">No presets loaded.</div>';
    return;
  }

  presets.forEach((preset, index) => {
    const row = document.createElement('div');
    row.className = 'file-row';
    
    // Left part: checkbox + name
    const left = document.createElement('div');
    left.className = 'file-left';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = preset.enabled;
    checkbox.addEventListener('change', () => {
      preset.enabled = checkbox.checked;
      updatePlot();
    });

    const nameSpan = document.createElement('span');
    nameSpan.className = 'name';
    nameSpan.textContent = preset.name;
    nameSpan.style.color = preset.color;  // keeps assigned color

    left.appendChild(checkbox);
    left.appendChild(nameSpan);
    row.appendChild(left);

    // Remove button
    const removeBtn = document.createElement('button');
    removeBtn.className = 'small-btn';
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', () => {
      presets.splice(index, 1);  // remove only this one
      renderFileList();
      updatePlot();
    });

    row.appendChild(removeBtn);

    filesList.appendChild(row);
  });
}

const FS = 192000; // used for digital biquad design

function dbToLinear(db){ return Math.pow(10, db/20); }
function linearToDb(x){ return 20*Math.log10(Math.max(1e-12, x)); }

/* RBJ cookbook coefficient builder for given filter type */
function biquadCoeffs(type, fc, Q, gainDb){
  const A = Math.pow(10, gainDb/40); // amplitude for shelving and peak
  const w0 = 2*Math.PI*fc/FS;
  const cosw0 = Math.cos(w0);
  const sinw0 = Math.sin(w0);
  const alpha = sinw0 / (2 * Math.max(0.0001, Q));
  let b0,b1,b2,a0,a1,a2;

  switch(type){
    case 'PK':
    case 'PEAK':
      b0 = 1 + alpha * A;
      b1 = -2 * cosw0;
      b2 = 1 - alpha * A;
      a0 = 1 + alpha / A;
      a1 = -2 * cosw0;
      a2 = 1 - alpha / A;
      break;
    case 'LSC': // low shelf
    case 'LSHELF':
    case 'LOWSHELF':
      {
        const sqrtA = Math.sqrt(A);
        const twoSqrtAalpha = 2 * sqrtA * alpha;
        b0 = A*( (A+1) - (A-1)*cosw0 + twoSqrtAalpha );
        b1 = 2*A*( (A-1) - (A+1)*cosw0 );
        b2 = A*( (A+1) - (A-1)*cosw0 - twoSqrtAalpha );
        a0 = (A+1) + (A-1)*cosw0 + twoSqrtAalpha;
        a1 = -2*( (A-1) + (A+1)*cosw0 );
        a2 = (A+1) + (A-1)*cosw0 - twoSqrtAalpha;
      }
      break;
    case 'HSC': // high shelf
    case 'HSHELF':
    case 'HIGHSHELF':
      {
        const sqrtA = Math.sqrt(A);
        const twoSqrtAalpha = 2 * sqrtA * alpha;
        b0 = A*( (A+1) + (A-1)*cosw0 + twoSqrtAalpha );
        b1 = -2*A*( (A-1) + (A+1)*cosw0 );
        b2 = A*( (A+1) + (A-1)*cosw0 - twoSqrtAalpha );
        a0 = (A+1) - (A-1)*cosw0 + twoSqrtAalpha;
        a1 = 2*( (A-1) - (A+1)*cosw0 );
        a2 = (A+1) - (A-1)*cosw0 - twoSqrtAalpha;
      }
      break;
    default:
      // Unknown: return null to indicate fallback
      return null;
  }

  // Normalize (so a0 = 1)
  return {
    b0: b0 / a0,
    b1: b1 / a0,
    b2: b2 / a0,
    a1: a1 / a0,
    a2: a2 / a0
  };
}

/* compute complex H(e^jw) magnitude for given biquad coeffs at frequency f */
function biquadMagnitudeAt(freq, coeffs){
  const w = 2*Math.PI*freq/FS;
  const cosw = Math.cos(w), cos2w = Math.cos(2*w);
  const sinw = Math.sin(w), sin2w = Math.sin(2*w);

  // numerator real/imag
  // b0 + b1 e^{-jw} + b2 e^{-j2w} == (b0 + b1 cosw + b2 cos2w) + j*(-b1 sinw - b2 sin2w)
  const nr = coeffs.b0 + coeffs.b1 * Math.cos(w) + coeffs.b2 * Math.cos(2*w);
  const ni = -coeffs.b1 * Math.sin(w) - coeffs.b2 * Math.sin(2*w);

  // denominator a0=1 assumed, a1 and a2 provided as positive sign (a0 + a1 e^{-jw} + a2 e^{-j2w})
  const dr = 1 + coeffs.a1 * Math.cos(w) + coeffs.a2 * Math.cos(2*w);
  const di = -coeffs.a1 * Math.sin(w) - coeffs.a2 * Math.sin(2*w);

  const numMag = Math.sqrt(nr*nr + ni*ni);
  const denMag = Math.sqrt(dr*dr + di*di);
  return Math.max(1e-12, numMag / denMag);
}

/* Gaussian fallback (original approx) */
function gaussianApproxMagnitudeDb(freq, f){
  const fc=f.fc||1000; const q=(f.q&&f.q>0)?f.q:1.0; const gain=f.gain||0;
  const bw=Math.max(1,fc/(q*2)); const diff=Math.log(freq)-Math.log(fc);
  const std=Math.log(1+bw/fc); if(std<=0)return 0;
  return gain*Math.exp(-0.5*(diff*diff)/(std*std));
}

/* Compute total gain in dB at freq for a single preset */
function presetGainAtFreqDb(freq, preset){
  // multiply magnitudes of each filter (in linear) then convert to dB, then add preamp
  let totalLinear = 1.0;
  for(const f of preset.filters){
    // try RBJ coefficients
    const coeffs = biquadCoeffs(f.type, f.fc, f.q, f.gain);
    if(coeffs){
      const mag = biquadMagnitudeAt(freq, coeffs); // linear
      totalLinear *= mag;
    } else {
      // fallback to gaussian approximation for compatibility
      const magDb = gaussianApproxMagnitudeDb(freq, f);
      totalLinear *= dbToLinear(magDb);
    }
  }
  const combinedDb = linearToDb(totalLinear) + (preset.preamp||0);
  return combinedDb;
}

/* Compute merged object to be plotted similarly (merged has filters array & preamp) */
function mergedGainAtFreqDb(freq, merged){
  // merged is already structured like a preset
  return presetGainAtFreqDb(freq, merged);
}

function computeMaxPreamp(merged, sampleFreqs) {
  // Compute merged filters response without preamp
  const gainsWithoutPreamp = sampleFreqs.map(f =>
    presetGainAtFreqDb(f, { filters: merged.filters, preamp: 0 })
  );
  const maxGain = Math.max(...gainsWithoutPreamp);

  // Safe preamp = offset to bring max to 0 dB, rounded to 0.01 dB
  const safePreamp = Math.min(0, -maxGain);
  return Math.round(safePreamp * 10) / 10;
}

/* ========== Plotting ========== */
function updatePlot() {
  // handle HiDPI
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(canvas.clientWidth * dpr);
  canvas.height = Math.floor(canvas.clientHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // clear canvas
  ctx.fillStyle = '#071322';
  ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);

  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  const left = 60, right = w - 12, top = 18, bottom = h - 40;

  // --- X-axis grid & labels (frequency) ---
  const majorFreqs = [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100,200,300,400,500,600,700,800,900,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,20000];
  ctx.fillStyle = '#9aa4b2';
  ctx.font = '12px Inter, Arial';
  ctx.textAlign = 'center';

  for(const f of majorFreqs){
    const x = xForFreq(f, left, right);
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1.4;
    ctx.moveTo(x, top);
    ctx.lineTo(x, bottom);
    ctx.stroke();

    let label = f >= 1000 ? (f / 1000) + 'k' : f.toString();
    ctx.fillText(label, x, bottom + 18);
  }

  // --- Y-axis grid & labels (dB) ---
  const minY = parseFloat(minDb.value);
  const maxY = parseFloat(maxDb.value);
  ctx.textAlign = 'right'; ctx.font = '12px Inter, Arial';
  for(let y = Math.ceil(minY); y <= Math.floor(maxY); y++){
    const yy = yToPixel(y, top, bottom, minY, maxY);
    if(y === 0){
      ctx.strokeStyle = 'rgba(255,183,77,0.9)';
      ctx.lineWidth = 2;
    } else if(y % 3 === 0){
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1.2;
    } else {
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
    }
    ctx.beginPath();
    ctx.moveTo(left, yy);
    ctx.lineTo(right, yy);
    ctx.stroke();

    if(y % 3 === 0 || y === 0){
      ctx.fillStyle = (y === 0) ? '#ffb74d' : '#9aa4b2';
      ctx.fillText(y + ' dB', left - 10, yy + 4);
    }
  }

  // --- handle presets ---
  const enabled = presets.filter(p => p.enabled);
  if(enabled.length === 0){
    mergedText.textContent = '';
    lastMerged = null;
    return;
  }

  // --- merge filters (without preamp) ---
  const merged = simpleMerge(enabled);

  // sample frequencies for plotting and max-preamp calculation
  const sampleCount = 4096;
  const sampleFreqs = new Array(sampleCount);
  const logMin = Math.log10(1);
  const logMax = Math.log10(96000);
  for (let i = 0; i < sampleCount; i++) {
    sampleFreqs[i] = Math.pow(10, logMin + (i / (sampleCount - 1)) * (logMax - logMin));
  }

  // --- compute max safe preamp and apply (rounded 0.01 dB) ---
  merged.preamp = computeMaxPreamp(merged, sampleFreqs);

  lastMerged = merged;

  // --- draw individual preset curves (faded) ---
  for(let idx = 0; idx < enabled.length; idx++){
    const p = enabled[idx];
    const values = sampleFreqs.map(f => presetGainAtFreqDb(f, p));
    ctx.beginPath();
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = hexToRgba(p.color, 0.45);
    for(let i = 0; i < values.length; i++){
      const x = xForFreq(sampleFreqs[i], left, right);
      const y = yToPixel(values[i], top, bottom, minY, maxY);
      if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  // --- draw merged curve ---
  const mergedValues = sampleFreqs.map(f => mergedGainAtFreqDb(f, merged));
  ctx.beginPath();
  ctx.lineWidth = 2.6;
  ctx.strokeStyle = '#7c9cff';
  ctx.setLineDash([]);
  for(let i = 0; i < mergedValues.length; i++){
    const x = xForFreq(sampleFreqs[i], left, right);
    const y = yToPixel(mergedValues[i], top, bottom, minY, maxY);
    if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // --- update merged text ---
  mergedText.innerHTML = '';
  mergedText.appendChild(buildMergedTextHTML(merged));
}


/* helpers for plot */
function hexToRgba(hex, alpha){
  const h = hex.replace('#','');
  const r = parseInt(h.substring(0,2),16);
  const g = parseInt(h.substring(2,4),16);
  const b = parseInt(h.substring(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function xForFreq(freq, left, right) {
  const logMin = Math.log10(1);       // 1 Hz
  const logMax = Math.log10(20000);   // 20 kHz visible max
  const t = (Math.log10(Math.min(freq, 96000)) - logMin) / (logMax - logMin);
  return left + t * (right - left);
}
function yToPixel(db, top, bottom, minY, maxY) {
  const t = (db - minY) / (maxY - minY);
  return bottom - t * (bottom - top);
}

function buildMergedTextHTML(merged){
  const container = document.createElement('div');
  container.style.fontSize = "1.05em";
  container.style.fontFamily = "monospace";

  const typeColor = "#7c9cff";

  // Preamp
  const preampDiv = document.createElement('div');
  preampDiv.innerHTML =
    `<span style="color:#ffb74d">Preamp:</span> <span style="color:#f0f0f0">${merged.preamp.toFixed(2)} dB</span>`;
  container.appendChild(preampDiv);
  container.appendChild(document.createElement('br'));

  // Grid
  const grid = document.createElement('div');
  grid.style.display = "grid";
  grid.style.gridTemplateColumns =
    "max-content max-content max-content max-content max-content max-content max-content max-content";
  grid.style.rowGap = "0.2em";
  grid.style.whiteSpace = "nowrap";

  // helper to build a padded cell
  const cell = (content, align, padRight) => {
    const wrap = document.createElement('div');
    wrap.style.display = "inline-block";
    wrap.style.textAlign = align;
    wrap.style.paddingRight = padRight;
    wrap.style.color = "#f0f0f0";
    wrap.textContent = content;
    return wrap;
  };

  const cellHTML = (html, align, padRight) => {
    const wrap = document.createElement('div');
    wrap.style.display = "inline-block";
    wrap.style.textAlign = align;
    wrap.style.paddingRight = padRight;
    wrap.innerHTML = html;
    return wrap;
  };

  merged.filters.forEach((f, i) => {
    // Filter number — left aligned, +1 space
    grid.appendChild(cellHTML(
      `<span style="color:#ffb74d">Filter ${i+1}:</span>`,
      "left",
      "0.6em"        // ≈ 1 space
    ));

    // Type — centered, +2 spaces
    grid.appendChild(cellHTML(
      `${f.type}`,
      "center",
      "1.2em"        // ≈ 2 spaces
    ));

    // Fc label — centered, +1 space
    grid.appendChild(cellHTML(
      `<span style="color:${typeColor}">Fc</span>`,
      "center",
      "0.6em"
    ));

    // Fc value — right aligned, +2 spaces
    grid.appendChild(cell(
      `${f.fc.toFixed(0)} Hz`,
      "right",
      "1.2em"
    ));

    // Gain label — centered, +1 space
    grid.appendChild(cellHTML(
      `<span style="color:${typeColor}">Gain</span>`,
      "center",
      "0.6em"
    ));

    // Gain value — right aligned, +2 spaces
    grid.appendChild(cell(
      `${f.gain >= 0 ? ' ' : ''}${f.gain.toFixed(2)} dB`,
      "right",
      "1.2em"
    ));

    // Q label — centered, +1 space
    grid.appendChild(cellHTML(
      `<span style="color:${typeColor}">Q</span>`,
      "center",
      "0.6em"
    ));

    // Q value — right aligned, no extra spaces
    grid.appendChild(cell(
      f.q.toFixed(2),
      "right",
      "0em"
    ));
  });

  container.appendChild(grid);
  return container;
}

// Run on page load to initialize everything
<!-- window.addEventListener('DOMContentLoaded', () => { -->
  <!-- // Update labels -->
  <!-- minDbLabel.textContent = minDb.value; -->
  <!-- maxDbLabel.textContent = maxDb.value; -->
  <!-- updatePlot(); -->
<!-- }); -->
/* debounce update to avoid thrashing on resize */
let _updateTimer = null;
function scheduleUpdate(){
  if(_updateTimer) clearTimeout(_updateTimer);
  _updateTimer = setTimeout(()=>{ updatePlot(); _updateTimer = null; }, 80);
}

/* initial render */
<!-- renderFileList(); -->
scheduleUpdate();

</script>
</body>
</html>
